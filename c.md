# c



[https://github.com/huihut/interview](https://github.com/huihut/interview)

[https://www.yuque.com/huihut/interview/readme](https://www.yuque.com/huihut/interview/readme)

### 函数

形式参数：在别调用函数中出现的参数

实际参数 ：在调用函数中出现的参数

#### inline

 内置函数\(C++特有 \)

* 不单独编为一段代码,而是直接插入每个调用处,调用时不按函数调用过程执行,而是直接将该函数的代码放在调用处顺序执行
*  可执行程序的代码长度增加，但执行速度加快，适用于函数体短小且调用频繁的情况（1-5行）\(保存/恢复现场的代价超过函数体自身代价的情况\)
* 不能包含分支、循环等复杂的控制语句
* 系统编译时会自动判断是否需要真正采用内置方式\(写了inline，最终也不一定真正成为内置函数\)
*  递归函数不能内置\(递归必须要保存/恢复现场\)
*  inline函数及调用函数必须在同一个源程序文件中，否则编译出错

####  函数的重载

*  重载：同一作用域中多个函数使用相同的名称
* 引入：对同一类功能的实现，仅参数的个数或类型不同，希望采用相同的函数名

 重载函数调用时的匹配查找顺序：

* （1）寻找参数个数、类型完全一致的定义\(严格匹配\)
* （2）通过系统定义的转换寻找匹配函数
* （3）通过用户定义的转换寻找匹配函数  

使用要求：

*  要求同名函数的参数个数、参数类型不能完全相同
*  返回类型及参数名不做检查
*  若参数类型是由typedef定义的不同名称的相同类型，则会产生二义性
*  尽量使同名函数完成相同或相似的功能，否则可能导致概念混淆

### 函数模板

 函数重载的不足：对于参数个数相同，类型不同，而实现过程完全相同的函数，仍要分别给出各个函数的实现

 函数模板： 建立一个通用函数，其返回类型及参数类型不具体指定，用一个虚拟类型来代替，该通用函数称为函数模板，调用时再根据不同的实参类型来取代模板中的虚拟类型，从而实现不同的功能

 有默认参数的函数

 引入：假设已经定义了某个函数，并进行了大量的应用后来随着要求的增加，需要扩充函数的功能并且增加相应的参数来满足扩充的功能含义：对函数的某一形参，大部分情况下都对应同一个实参值时，可以采用默认参数\(默认值为常量\)形式：返回类型 函数名\(无默认参数形参,有默认参数形参\){函数体}

*  便于函数功能的扩充，减少代码维护，修改的数量
*  允许有多个默认参数，但必须是连续的最后几个
*  若有多个默认参数，调用时，前面使用缺省值，后面不使用缺省值，则前面也要加上

####  变量的存储类别

 应用程序执行时的内存分布

* 程序\(代码\)区 存放程序的执行代码
* 静态存储区 程序执行中，变量占固定的存储空间
* 动态存储区 程序执行中，变量根据需要分配不同位置的存储空间
*  自动变量占动态存储区,静态局部变量占静态存储区，缺省声明为自动变量
*  若定义时赋初值，自动变量在函数调用时执行，每次调用均重复赋初值；静态局部变量在第一次调用时执行，以后每次调用不再赋初值，保留上次调用结束时的值

在定义范围外使用全局变量时，应加上extern的说明，extern不分配存储空间![](https://www.hlmmd.me/wp-content/uploads/2019/03/image-3.png)

####  头文件

* 类型及类的声明
* 函数的声明
* inline函数的定义与实现
* 符号常量的定义及常变量的定义
* 全局变量的extern声明
* 其它需要的头文件

 头文件的包含方式：

* \#include &lt;文件名&gt;：直接到系统目录中寻找，找到则包含进来，找不到则报错
* \#include "文件名"：先在当前目录中寻找，找到则包含进来，找不到则再到系统目录中寻找，找到则包含进来，找不到则报错

### 数组

#### 数组初始化

![](https://www.hlmmd.me/wp-content/uploads/2019/03/image-4.png)

### 5.5.6.字符串处理函数

① strcat\(char s\[\], const char t\[\]\)② strcpy\(char s\[\], const char t\[\]\)③ strcmp\(const char s\[\], const char t\[\]\)④ strlen\(const char s\[\]\)

### 指针

 某一变量的地址，称为指向该变量的指针 指针=地址

定义指针：数据类型 \*变量名

*  数据类型称为该指针变量的基类型
*  变量中存放的是指向该数据类型的地址

指针变量的++/--单位是该指针变量的基类型【指针变量++⇔ 所指地址+=sizeof\(基类型\)】

 void可以声明指针类型，但不能++/-- ，因为不知道基类型的大小

*  \*比后缀++/--优先级低\*:3 后缀:2
* \*与前缀++/--优先级相同，右结合\*:3 前缀:3

以下这段函数并不能实现交换两个数的效果C/C++中函数参数是单向传值，形参的改变不能影响实参

```text
void swap(int x, int y)
{    
	int t;
	t = x;
	x = y;
	y = t;
}
```

*  指针变量做函数参数，虽然可以通过形参\(实参地址\)来间接访问实参，从而达到改变实参值 的目的，但本质上仍然是单向传值，而不是形参值回传实参
* 指针变量做参数，可以同时得到多个改变的实参值，从而达到一个函数返回多个值的目的
* 必须通过改变形参指针变量所指变量\(即实参\)值的方法来达到改变实参值的目的，仅通过改变形参指针变量的值的方法是无效的
* 指针变量的使用，一定要有确定的值，否则会出现错误

####  数组与指针

 数组的指针：数组的起始地址\( ⇔ &a\[0\]\)

数组元素的指针：数组中某个元素的地址

 数组名代表数组首地址，指针是地址，但本质不同\(sizeof\(数组名\)/sizeof\(指针\)大小不同\)

 p\[i\] ⇔ \*\(p+i\)

数组的首地址不可变指针变量++ ⇔所指地址 += sizeof\(基类型\)指针变量-- ⇔所指地址 -= sizeof\(基类型\)指针变量+n ⇔所指地址 + n\*sizeof\(基类型\)指针变量-n ⇔所指地址 - n\*sizeof\(基类型\)指针变量1-指针变量2 ⇔地址差/sizeof\(基类型\)

####  多维数组与指针

####  字符串与指针

 字符指针与字符数组的区别

*  字符数组占用一定的连续存储空间，而指针仅有一个有效地址的存储空间
*  赋初值的方式相同，但含义不同
*  字符数组在执行语句中赋值时只能逐个进行，而字符指针仅能整体赋首址
*  数组首地址的值不可变，指针的值可变

![](https://www.hlmmd.me/wp-content/uploads/2019/03/image-5.png)

####  函数与指针

 函数的地址

 程序\(代码\)区:

* 存放程序的执行代码由若干函数的代码组成，每个函数占据一段连续内存空间
* 每个函数的内存空间的起始地址，称为函数的地址\(指针\)
* 函数名代表函数的首地址

函数指针

*  指向函数的指针变量的定义：
* 数据类型 \(\*指针变量名\)\(形参表\)
* int \(\*p\)\(int,int\);

  
指向函数的指针做函数参数

*  适用于在函数中每次调用不同的函数
* 被调用的函数必须有相同的返回类型和形参表列

 return中的返回值必须是指针（地址）

 不能返回一个自动变量/形参的地址，否则可能出错

####  指针数组和指向指针的指针

 指针数组 ：

定义：数据类型 \*数组名\[数组长度\] int \*p\[4\];

 指针数组与指向m个元素的一维数组的指针的比较

 int \*p\[4\];p是数组名，有4个元素，每个元素是int \*p+1实际+4，因为数组类型为指针

int \(\*p\)\[4\];p是指针变量名，指向由4个元素组成的一维数组p+1实际+16，因为p的基类型为int\*4

 二维字符数组和一维指针数组的区别

* 二维字符数组分配实际的字符串存储空间，在执行过程中可以修改字符串任意位置的值
* 一维指针数组不分配实际字符串存储空间，只是指向字符串常量，在执行过程中字符串值不能改变

####  const指针

 共用数据的保护：一个数据可以通过不同的方式进行共享访问，因此可能导致数据因为误操作而改变，为了达到既能共享，又不会因误操作而改变，引入共用数据保护的概念

 指向常量的指针变量

*  const 数据类型 \*指针变量名
* 数据类型 const \*指针变量名
*  不能通过指针修改变量的值\(仍可以通过变量修改\)
* 指针变量可以指向其它同类型变量\(不必在定义时初始化\)
* 适用于不希望通过指针修改变量值的情况
*  指向常量的指针变量可以指向常变量、普通变量，但是普通指针不能指向常变量

![](https://www.hlmmd.me/wp-content/uploads/2019/03/image-6.png)

 常指针

 数据类型 \*const 指针变量名

*  可以通过指针修改变量的值
* 指针变量指向固定变量\(必须在定义时初始化\)后，不能再指向其它同类型变量
* 适用于希望指针始终指向某个变量的情况

 指向常量的常指针

 const 数据类型 \*const 指针变量名

*  不能通过指针值修改变量的值
* 指针变量指向固定变量\(必须在定义时初始化\)后，不能再指向其它同类型变量
* 适用于既希望始终指向固定变量，又希望不能通过指针修改变量值的情况

 void指针类型

*  不能直接通过void指针访问数据\(不知道基类型\)，必须强制转换为某种确定数据类型后才能访问
*  非void型的指针可直接赋值给void类型，void类型赋值给非void类型时必须强制转换

![](https://www.hlmmd.me/wp-content/uploads/2019/03/image-7.png)

 引用

 变量的别名

*  引用不分配单独的空间\(指针变量有单独的空间\)
* 变量的定义：分配空间
* 变量的声明：不分配空间

 引用需在声明时进行初始化，指向同类型的变量，在整个生存期内不能再指向其它变量

 不能声明指向数组的引用、引用数组和指向引用的指针，但可声明数组元素的引用和指向指针的引用

 引用作函数参数

*  当形参是引用时，不需要声明时初始化，调用时，形参不分配空间，只是当作实参的别名，因此对形参的访问就是对实参的访问
* 实参虽然是变量名，但传递给形参的实际上是实参的地址，同时形参不单独分配空间，只是虚实结合\(P.187 地址传递方式①-②的解释，没错误，但不好理解，可忽略不看\)
* 引用允许传递
* 当引用做函数形参时，实参不允许是常量/表达式，否则编译错误

####  共用体

*  所有成员从同一内存开始，共用体的大小为其中占用空间最大的成员的大小
* 给一个共用体成员赋值后，会覆盖其它成员的值，因此只有最后一次存放的成员是有效的
* 其它所有定义、使用方法同结构体

####  枚举类型

*  枚举类型和元素的命名同变量
* 枚举元素也称枚举常量，不是字符串，不加""，作为整型常量处理，值从0开始顺序递增，也可自行指定，在程序执行中值不可变
*  如果执行的常量值出现重叠，不算错误 enum week {sun=3, mon=1,tue,wed,thu,fri,sat};

 enum 枚举类型名{枚举元素1，...，枚举元素n}

* enum 枚举类型名 变量名\(在C++下定义时，enum关键字可省略\)
* enum week w1, w2;
* 不能直接赋整型量，需要进行强制类型转换

