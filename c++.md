# c++



###  类和对象的特性

*  用sizeof\(类名\)计算类的大小时，成员函数不占用空间
* 缺省情况下，类的数据成员和成员函数都是私有的，不能被外界所访问，因此是无意义的
* 通过类的成员访问限定符\(private/public\)，可以指定成员的属性是私有\(private\)或公有\(public\)，私有不能被外界访问,公有可被外界所访问，由实际应用决定
*  在C++中，结构体也可以加成员函数，能够实现和类完全一样的功能。
*  若不指定成员访问限定符，则struct缺省为public，class缺省为private

####  类的成员函数 

 体内实现：class中给出成员函数的定义及实现过程

* 体内实现缺省是inline，具体是否inline由系统决定

 体外实现：class中给出成员函数的定义，class外部\(class后\)给出成员函数的实现

* 函数实现时需要加类的作用域限定符::
* 缺省不是inline，可用inline显式指定，具体是否inline仍由系统决定

 成员函数的性质

*  对应类的成员函数\(类函数\)，一般的普通函数称为全局函数
* 成员函数的定义、实现及调用时参数传递的语法规则与全局函数完全相同
* 成员函数也受类的成员访问限定符的约束，只有公有的成员函数可以被外部调用
* 私有和公有的成员函数均可以访问/调用本类的所有数据成员/成员函数，不受private/public的限制\(private/public是用来限制外部对成员的访问\)

####  成员函数的存储方式

*  每个类的实例对象仅包含数据成员\(sizeof\(类\)=所有数据成员之和\)，根据不同的定义位置占用不同的数据空间\(静态数据区或动态数据区\)
* 类的成员函数占用函数\(代码\)区，每个类的每个成员函数\(包括体内实现和体外实现\)只占用一段空间，所有该类的对象共用成员函数的代码空间
* 当通过对象调用成员函数时，系统会缺省设置一个隐含的this指针，指向被调用的对象，并以此来区分成员函数对数据成员的访问

####  类的封装性和信息隐蔽

*  公有函数可被外界调用，称为类的公共/对外接口通过对象.函数\(实参表\)的方法进行调用，将函数称为方法，将调用过程称为消息传递
* 如果允许外界直接改变某个数据成员的值，可直接设置属性为public\(不提倡\)
* 其它不愿公开的数据成员和成员函数可设置为私有,对外部隐蔽，但仍可通过公有函数进行访问及修改
* 公有函数的形参称为提供给外部的访问接口，在形参的数量、类型、顺序不变的情况下，私有成员的变化及公有函数实现部分的修改不影响外部的调用
*  将类的声明\(\*.h\)与类成员函数的实现\(\*.cpp\)分开
*  在需要外部调用的地方，只要提供声明部分即可，类的实现可通过库文件\(\*.lib\)或动态链接库\(\*.dll\)的方式提供，而不必提供实现的源码

### 类和对象的使用

####  构造函数

对象的初始化

 对象的初值：

* 与普通变量相同，在静态数据区分配的对象，数据成员初值为0；
* 在动态数据区分配的对象，数据成员的初值随机

 若全部成员都是公有,可按结构体的方式进行初始化\(若有私有成员，不能用此方法，新版本C++允许私有成员函数\)

构造函数： 完成对象的初始化工作,对象建立时被自动调用

 与类同名，无返回类型

* 对象建立时被自动调用
* 构造函数必须公有
* 若不指定构造函数，则系统缺省生成一个构造函数，形式为无参空体
* 若用户定义了构造函数，则缺省构造函数不再存在
* 构造函数既可以体内实现，也可以体外实现
* 允许定义带参数的构造函数，以解决无参构造函数初始化各对象的值相同的情况

 有参构造函数可以使用参数初始化表来对数据成员进行初始化![](https://www.hlmmd.me/wp-content/uploads/2019/03/image-10.png)

*  构造函数允许重载
*  构造函数允许带默认参数，但要注意可能与重载产生二义性冲突
*  构造函数也可以显式调用，一般用于带参构造函数

####  析构函数

 在对象被撤销时\(生命期结束\)时被自动调用，完成一些善后工作\(主要是内存清理\)，但不是撤销对象本身

 形式：~类名\(\); 无返回值\(非void,也不是int\)，无参，不允许重载

*  对象撤销时被自动调用，用户不能显式调用
* 析构函数必须公有
* 若不指定析构函数，则系统缺省生成一个析构函数,形式为无参空体
* 若用户定义了析构函数，则缺省析构函数不再存在
* 析构函数既可以体内实现，也可以体外实现
* 在没有数据成员需要动态内存申请的情况下，一般不需要定义析构函数
* 在有数据成员需要动态内存申请的情况下，也可以不定义析构函数而通过其他方法释放

####  调用构造函数和析构函数的顺序

 构造函数：

*  自动对象\(形参\) ：函数中变量定义时
* 静态局部对象 ：第一次调用时
* 静态全局/外部全局对象：程序开始前
* new申请的对象 ：new时

析构函数：

* 自动对象\(形参\) ：函数结束时
* 静态局部对象：程序结束时\(在全局之前\)
* 静态全局/外部全局对象：程序结束后
* new申请的对象 ：delete时

malloc/free不会调用构造函数和析构函数，只申请空间。

相同性质的多个对象的调用顺序

 构造函数按定义的顺序依次执行，析构函数按构造函数进栈的概念反向依次执行

不同性质的变量、new和delete申请释放的变量，不遵循栈规则

####  对象数组

 若未定义构造函数或构造函数无参，则按简单对象使用无参构造函数的规则进行

如果定义了构造函数，但没有无参构造函数，则声明报错。

####  对象指针

指向成员对象的指针：类比struct，但只能访问public

 指向对象的成员函数的指针 :

*  \(1\) 返回类型匹配
* \(2\) 形参表匹配
* \(3\) 类匹配

```text
#include <iostream>
using namespace std;
class Time
{
  private:
    int hour;
  public:
    Time()  {    hour = 0;  }
    void display()  {  cout << hour << endl;    }
};
int main()
{
    Time t1;
    void (Time::*p)();
    p = &Time::display;
    (t1.*p)();
}
```

*  定义：成员函数返回类型 \(类::\*指针变量名\)\(形参表\)
* 赋值：指针变量名 = &类::成员函数名
* 对象的成员函数必须是public
* 使用：\(对象名.\*指针变量名\)\(实参表\)

 this指针

*  隐式使用，相当于通过对象调用成员函数时传入该对象的自身的地址
* 也可以显式使用\(但不能显式定义\)

####  共用数据的保护

 常对象与常对象成员

*  const 类名 对象名\(初始化实参表\)
*  类名 const 对象名\(初始化实参表\)
*  必须在定义时进行初始化
* 不能调用普通成员函数\(即使不改变数据成员的值\)

 常对象中的所有数据成员在程序执行过程中值均不可变，如果只需要限制部分成员的值在执行过程中不可变，则需要引入常对象成员的概念

*  常数据成员：该数据成员的值在执行中不可变
*  常成员函数：该函数只能引用成员的值，不能修改

 常成员函数：返回类型 成员函数名\(形参表\) const;

常数据成员要在构造函数中初始化，使用中值不可变，在构造函数中初始化时，必须用参数初始化表形式，而不能用赋值形式![](https://www.hlmmd.me/wp-content/uploads/2019/03/image-11-1024x263.png)

*  常成员函数只能引用类的数据成员\(无论是否常数据成员\)的值，而不能修改数据成员的值
*  常成员函数可以调用本类的另一个常成员函数，但不能调用本类的非常成员函数
*  若希望常成员函数能强制修改数据成员，则要将数据成员定义为mutable
*  若定义对象为常对象，则只能调用其中的常成员函数\(不能修改数据成员的值\),而不能调用其中的普通成员函数\(即使该成员不修改数据成员的值\)
*  不能定义构造/析构函数为常成员函数
*  全局函数不能定义const

![](https://www.hlmmd.me/wp-content/uploads/2019/03/image-12.png)

####  对象的动态建立和释放

 C++中一般不建议使用C方法动态申请

 C++中delete时，只要是数组，必须加\[\]

####  对象的赋值与复制

*  两个对象属于同一个类，且不能在定义时赋值
* 将对象2的全部数据成员的值对应赋给对象1的全部数据成员，不包括成员函数\(理解为整体内存拷贝，可参考memcpy函数\)
* 若对象数据成员是指针及动态分配的数据，则可能导致不可预料的后果（例如多次调用析构函数，引起重复释放）

 建立新对象时自动调用复制构造函数（也称为拷贝构造函数）

  
复制构造函数： 类名\(const 类名 &引用名\)

*  用一个对象的值去初始化另一个对象
* 若不定义复制构造函数，则系统自动定义一个，参数为const型引用，函数体为对应成员内存拷贝
* 若定义了复制构造函数，则系统缺省定义的消失
* 允许体内实现或体外实现
* 复制构造函数和普通构造函数（可能多个）的地位平等，调用其中一个后就不再调用其它构造函数

 复制构造函数的调用时机：

*  用已有对象初始化一个新建立的对象时
* 函数形参为对象，实参向形参进行单向传值时
* 函数的返回类型是对象时
* 不包括执行语句中的赋值\(=\)操作，执行赋值\(=\)操作通过赋值运算符\(=\)的重载来实现\(第10章\)
* 除非有动态内存申请或其它特殊功能，否则不需要定义复制构造函数
* 
#### 静态成员

*  静态数据成员不属于任何一个对象，不在对象中占用空间，单独在静态数据区分配空间\(初值为0，不随对象的释放而释放\)，一个静态数据成员只占有一个空间，所有对象均可共享访问
* 静态数据成员同样受类的作用域限制
* 静态数据成员必须进行初始化，初始化位置在类定义体后，函数体外进行\(此时不受类的作用域限制\)数据类型 类名::静态数据成员名=初值;
* 虽然可以通过this指针访问，但是数据不在一起
*  不能通过参数初始化表进行初始化，但可以通过赋值方式初始化
*  既可以通过类型引用，也可以通过对象名引用
*  静态数据成员不是面向对象的概念，它破坏了数据的封装性，但方便使用，提高了运行效率

 静态成员函数

 没有this指针，不属于某个对象

 允许体内实现或体外实现

 静态成员函数中可以直接访问静态数据成员

####  友元

 友元不是面向对象的概念，它破坏了数据的封装性，但方便使用，提高了运行效率

 可以成为类的友元的成分：

* 全局函数
* 其它类的成员函数
* 其它类

友元的声明方式：在类的声明中，相应要成为友元的函数/类前加friend关键字即可  


*  友元是单向而不是双向的
*  友元不可传递
*  C++规定同类的不同对象互为友元

####  类模板

*  仅适用于参数个数相同、类型不同，实现过程完全相同的情况
* 类模板可以看作是类的抽象，称为参数化的类
* 类模板成员函数体外实现时形式有所不同
* 类型定义允许多个template &lt;class T1, class t2&gt;

###  运算符重载

 运算符重载的方法

 定义一个重载运算符的函数，当执行运算符时，自动执行该函数，达到相应的目的

*  形式：返回类型 operator 运算符\(形参表\)
* {重载函数实现}
*  用operator 运算符来表示对应运算符的函数
*  对象 运算符 另一个值\(可以不是对象、可以无\)被解释为对象.operator运算符\(另一个值\)
*  c1 + c2 ⇔ c1.operator+\(c2\)
*  运算符被重载后，原来用于其它数据类型上的功能仍然被保留\(重载\)，系统根据重载函数的规则匹配

####  运算符重载的规则

* 对已有运算符进行重载，不能定义新运算符
* 除5个运算符外都允许重载\(唯一的三目 ?: 不允许\)
* 不能改变操作对象的个数
* 不能改变优先级
* 不能改变结合性
* 不允许带默认参数
* 重载运算符的两侧至少有一个是类对象
* =和&系统缺省做了重载，=是对应内存拷贝,&取地址
* 应当使重载运算符的功能与标准相同/相似\(建议\)

![](https://www.hlmmd.me/wp-content/uploads/2019/03/image-15.png)

####  运算符重载函数做为类成员函数和友元函数

 运算符的同一种重载实现，友元/成员只能选择一个

 用全局普通函数也能实现运算符重载，但因为只能访问public对象，或通过类的公有成员函数访问private部分，因此效率低，一般不用

 成员函数与友元函数的区别：

对单目运算符

* 成员函数是空参数
* 友元函数是一个参数\(必须是对象\)

对双目运算符

* 成员函数是一个参数\(可不是对象\)
* 对象\(this\) 双目运算符 参数
* 友元函数是两个参数\(一个必须是,一个可不是\)
* 第一个参数 双目运算符 第二个参数

####  不同类型数据间的转换

 用转换构造函数进行类型转换

 形式：类名\(一个形参\)

{函数实现}

*  只能带一个参数，非该类的数据类型，将该参数转换为对应的对象
* 系统无缺省定义，根据需要自行定义并使用
* 
 用类型转换函数进行类型转换

 一个类对象转换为另一个类型的数据

形式：operator 类型名\(\)

{函数体实现;}

*  返回类型不是缺省的int，由类型名决定，无参数
* 只能是成员函数形式
* 在需要类型转换的地方被系统自动地隐式调用

###  继承和派生

提高代码的可重用性

*  基类与派生类：基类\(父类\)，指已有的类
* 派生类\(子类\)，新建立的类

 单继承与多继承：一个派生类从一个基类派生，则称为单继承，否则称为多继承

 派生类的声明方式

class 派生类名:private/public 基类名1,

private/public 基类名2,

...private/public 基类名n

{private:私有成员;

public:公有成员;

};

* 基类名前的private/public称为基类存取限定符根据限定符的不同分别称为私有继承和公有继承
* 若基类前不加限定符，缺省是private
* 根据需要加入派生类自己特有的成员

####  派生类的构成

*  派生类对象所占的空间：
* 基类数据成员所占空间总和 + 派生类数据成员所占空间的总和
* 派生类可访问的成员函数：
* 基类成员函数 + 派生类成员函数
*  继承基类的全部数据成员\(不一定都可以访问\)
* 继承基类除构造函数和析构函数外的全部成员函数\(不一定都可以访问\)
* 友元不能继承
* 派生类的数据成员/成员函数允许和基类的同名，不同的继承方式访问方法不同\(暂不讨论\)

 派生类的成员访问属性

* 基类的成员函数访问基类的成员：全部
* 基类的成员函数访问派生类的成员：不允许
* 作用域外通过基类访问基类的成员：public
* 作用域外通过基类访问派生类的成员 ：不允许
* 派生类的成员函数访问基类的成员：分析讨论
* 派生类的成员函数访问派生类的成员 ：全部
* 作用域外通过派生类访问基类的成员 ：分析讨论
* 作用域外通过派生类访问派生类的成员 ：public

 保护段与保护继承

 在多级继承中，基类的private不可访问，public部分被私有继承则不可再传递，若公有继承则对于整个继承序列的外部均可访问，为了加强灵活性，引入保护段及保护继承 protected

* protected段的成员对外不可访问，对内可被任意访问，其成员函数可任意访问类的其它成员\(等同于private属性\)
* protected段的成员继承后可被派生类访问\(protected被private继承后当做派生类的private，protected被public继承后当做派生类的protected\)
* 若该类不被其它类所继承，则声明保护段无意义\(不被继承的情况下与声明为private等价\)

![](https://www.hlmmd.me/wp-content/uploads/2019/03/image-16.png)![](https://www.hlmmd.me/wp-content/uploads/2019/03/image-17.png)  


 派生类与基类的成员同名

*  数据成员同名：
  * 派生类屏蔽基类，通过直接访问方式可访问派生类的成员，通过加类的作用域符的方式可访问基类成员
* 成员函数同名：
  * 参数的个数、类型完全相同
    * 与数据成员同名的处理方式相同
  * 参数的个数、类型不同
    * 与数据成员同名的处理方式相同

 派生类优先于基类，称为支配规则

 基类对象不可访问部分的强制访问

*  任何继承方式派生类均不能访问基类的private
* 派生类的对象中包含了基类对象\(包括private部分\)
*  不可访问，又占空间

 解决方法：继承后，基类的私有部分不可被派生类直接访问，但是可以通过基类的可访问的成员函数进行间接访问

####  派生类的构造函数和析构函数

 构造函数不能继承，同时派生中又含有基类的成员，需要能同时初始化基类和派生类的数据成员，因此在派生类的构造函数中激活基类的构造函数

形式：派生类名\(参数\):基类名\(参数\)

{函数体\(一般是对派生类新增成员的初始化\)}

 构造函数的调用顺序：

先基类，再派生类\(在派生类的构造函数中先自动激活基类的构造函数\)

 派生类的析构函数

*  在派生类对象出作用域时，自动调用派生类的析构函数，在其中再自动调用基类的析构函数

 析构函数的调用顺序：

*  先派生类，再基类\(与构造函数的顺序相反\)

 析构函数的使用：

* 派生类的数据成员无动态内存申请的情况下一般不需要定义派生类的析构函数
* 若基类有动态内存申请，派生类无，则基类需要定义，派生类不需要
* 
####  多重继承

 多重继承引起的二义性问题\(成员同名\)

某一个基类与派生类的成员同名：

按单继承的方式进行处理

\(支配规则:派生类直接访问，基类加作用域符 \)

两个以上的基类中的成员同名：分别加不同的基类作用域符区分

两个以上的基类与派生类的成员同名：派生类直接访问，不同基类加作用域符区分

通过直接/间接方式继承同一个基类两个导致的同名：通过可区分的类的作用域符来进行区分

####  虚基类

 引入：间接基类被多次继承而产生的重复问题

 针对某个间接基类被多次继承而产生的多个无名对象，从而导致派生类中有多份相同的数据成员拷贝的情况，引入虚基类，使相同基类只保留一份数据成员

 声明：class 派生类名: virtual存取限定符 基类名 {...};![](https://www.hlmmd.me/wp-content/uploads/2019/03/image-18.png)

####  基类与派生类的转换

 赋值兼容规则：在需要基类对象的任何位置，均可以使用公有继承的派生类对象

*  只有公有继承适用，私有及保护继承会导致基类的公有部分对外不可访问，因此不可用
*  使用时，将派生类中的基类无名实例对象对应空间拷贝给基类，其余部分丢弃
*  派生类对象可初始化基类的对象或引用
* 派生类对象可出现在函数参数/返回值为基类的地方
* 派生类对象可赋值给基类
* 派生类对象的指针可出现在基类指针出现的位置

###  多态性与虚函数

 C++程序设计中多态的含义：同一作用域内有多个不同功能的函数可以具有相同的函数名

*  静态多态：在程序编译时已确定调用函数\(函数重载\)
* 动态多态：在程序运行时才确定操作的对象\(虚函数\)
* 
 在类的继承层次中，对于参数个数、参数类型完全相同的同名函数，采用支配规则进行访问，要通过不同的对象来访问不同的同名函数\(调用形式不同\)

 通过赋值兼容规则，可使调用形式相同，但只能访问派生类中的基类部分

 为了能采用同一调用形式来访问类继承层次中的同名函数，引入虚函数\(调用形式相同\)

 虚函数的定义与使用

 定义：

* 在基类的函数定义前加virtual声明
* 未加virtual前，基类指针变量 = &派生类对象形式。适用赋值兼容规则，访问的是派生类中的基类部分
* 加virtual后，突破此限制，访问派生类的同名函数

 使用：

*  virtual在类定义时出现，函数体外实现部分不能加
*  在类的继承序列中，只需要在最开始的基类中加virtual声明，后续派生类可以不加\(建议加\)
*  类的继承序列中该同名函数的参数个数、参数类型必须完全相同
*  若类的继承层次中同名虚函数仅返回类型不同，则象重载一样，认为是错误
*  若派生类中无同名函数，则自动继承基类
*  若派生类中有同名函数，其参数个数、参数类型与基类的虚函数不同，则失去多态性，按支配规则及赋值兼容规则处理
*  对于派生类中的其它非virtual仍适用赋值兼容规则
*  只有通过基类指针/引用方式访问时才适用虚函数规则,其它形式\(对象/自身指针/引用\)仍用原来的规则
* 若把函数重载理解为横向重载（同一类中），则虚函数可理解为纵向重载（类的继承层次中）
* 非类的成员函数不能声明为多态
* 类的静态成员函数不能声明为多态

 支配规则、赋值兼容规则、虚函数的区别：

*  支配规则：通过自身对象、指针、引用访问\(自身的\)虚函数、普通函数
* 赋值兼容规则：通过基类指针、对象、引用访问\(派生类中基类部分的\) 普通函数
* 虚函数：通过基类指针、引用访问\(基类和派生类的同名\)虚函数

 虚析构函数

 在通过基类指针动态申请派生对象时，会出现对象撤销时无法调用派生类析构函数的问题

 解决：将基类的析构函数声明为虚函数

virtual ~ 类名\(\)

 {函数体}

####  纯虚函数与抽象类

在类的多继承层次中，可能会出现多个基类并存的现象，若各基类有同名函数并希望使用虚函数机制，则需要引入一个更高层次的类，该类无实际意义，不进行具体操作，称为抽象类

 抽象类的定义：C++中无明确的关键字定义，只要声明某一成员函数为纯虚函数即可

 纯虚函数的声明：virtual 返回类型 函数名\(参数表\) = 0;

例：class V {

public:

 virtual void display\(\)=0;

};

 抽象类的使用：

* 抽象类不能有实例对象，但可用于声明指针或引用
* 抽象类中定义数据成员及有实际意义的成员函数都是无意义的，但为了简化继承序列，可以进行定义，供派生类使用\(会导致理解混乱，不推荐\)
*  抽象类的直接派生类的同名虚函数必须定义，否则继承抽象类的纯虚函数，也成为抽象类\(若不需要，可定义为空虚函数\)

