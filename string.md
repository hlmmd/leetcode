# String

## 28. Implement strStr\(\)

实现 strstr\(\)函数

当needle字符串为空的时候，返回0。

基本解法：brute force 滑动窗口。

```cpp
class Solution {
public:
	int strStr( string haystack, string needle )
	{
		if ( needle.length() == 0 )
			return(0);

		for ( int i = 0; haystack[i]; i++ )
		{
			for ( int j = 0;; j++ )
			{
				if ( needle[j] == 0 )
					return(i);
				if ( haystack[i + j] == 0 )
					return(-1);
				if ( haystack[i + j] != needle[j] )
					break;
			}
		}

		return -1;
	}
};
```

此外还有KMP算法、BM算法、Sunday算法用于解决该问题。

##  205. Isomorphic Strings

Given two strings **s** and **t**, determine if they are isomorphic.

Two strings are isomorphic if the characters in **s** can be replaced to get **t**.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

**Example 1:**

```text
Input: s = "egg", t = "add"
Output: true
```

**Example 2:**

```text
Input: s = "foo", t = "bar"
Output: false
```

**Example 3:**

```text
Input: s = "paper", t = "title"
Output: true
```

判断一个字符串s能否通过对字符进行一一映射变换得到字符串t。

记录每个字符对应的映射值，初值为0。如果双方的映射都是0，那么说明这两个字符还没有建立过映射关系。否则，就要检查是否满足两条映射关系，如果不满足，说明不满足一一映射条件。

```cpp
class Solution
{
  public:
	bool isIsomorphic(string s, string t)
	{
		if (s.length() != t.length())
			return false;

		vector<int> pa(128, 0);
		vector<int> pb(128, 0);
		for (int i = 0; s[i]; i++)
		{
			if (pa[s[i]] == 0 && pb[t[i]] == 0)
			{
				pa[s[i]] = t[i];
				pb[t[i]] = s[i];
			}
			else if (pa[s[i]] != t[i] || pb[t[i]] != s[i])
				return false;
		}
		return true;
	}
};
```

##  242. Valid Anagram

判断两个字符串是否同构。统计每个字符的个数即可。

```cpp
class Solution {
public:
	bool isAnagram( string s, string t )
	{
		if ( s.length() != t.length() )
			return(false);
		vector<int>	c1( 26, 0 );
		vector<int>	c2( 26, 0 );
		for ( auto ch : s )
			c1[ch - 'a']++;
		for ( auto ch : t )
			c2[ch - 'a']++;
		for ( int i = 0; i < c1.size(); i++ )
			if ( c1[i] != c2[i] )
				return(false);

		return(true);
	}
};
```

## 257. Binary Tree Paths

求二叉树所有从根结点到叶子结点的路径。

DFS递归即可。

```cpp
class Solution {
public:
	vector<string> ret;
	vector<string> binaryTreePaths( TreeNode* root )
	{
		string temp;
		if ( root == NULL )
			return(ret);
		helper( root, temp );
		return(ret);
	}


	void helper( TreeNode* root, string temp )
	{
		temp += to_string( root->val );
		if ( root->left == NULL && root->right == NULL )
		{
			ret.push_back( temp );
			return;
		}
		temp += "->";
		if ( root->left )
			helper( root->left, temp );
		if ( root->right )
			helper( root->right, temp );
	}
};
```

##  383. Ransom Note

Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.

Each letter in the magazine string can only be used once in your ransom note.

判断Ransom字符串能不能由magazines里面的字符组成。还是统计字符个数。

```cpp
class Solution
{
public:
	bool canConstruct(string ransomNote, string magazine)
	{

		vector<int> count(26, 0);
		for (auto ch : magazine)
			count[ch - 'a']++;
		for (auto ch : ransomNote)
		{
			if (count[ch - 'a']-- <= 0)
				return false;
		}

		return true;
	}
};
```

##  387. First Unique Character in a String

字符串中第一个只出现一次的字符。先循环统计个数，再循环找到index

```cpp
class Solution
{
  public:
	int firstUniqChar(string s)
	{
		vector<int> count(26, 0);
		for (auto ch : s)
			count[ch - 'a']++;
		for (int i = 0; s[i]; i++)
			if (count[s[i] - 'a'] == 1)
				return i;
		return -1;
	}
};
```

##  389. Find the Difference

Given two strings **s** and **t** which consist of only lowercase letters.

String **t** is generated by random shuffling string **s** and then add one more letter at a random position.

Find the letter that was added in **t**.  
t是在s变换的基础上加了一个字符，那对于s+t来说，只有一个字符出现奇数次，其他所有字符都出现了偶数次，可以用异或运算找到这个单独的字符。

```cpp
class Solution
{
  public:
	char findTheDifference(string s, string t)
	{

		char ret = 0;
		for (auto ch : s)
			ret ^= ch;
		for (auto ch : t)
			ret ^= ch;
		return ret;
	}
};
```

##  438. Find All Anagrams in a String

 Given a string **s** and a **non-empty** string **p**, find all the start indices of **p**'s anagrams in **s**.

求s的所有子串中有多少与p同构。

[https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/92007/Sliding-Window-algorithm-template-to-solve-all-the-Leetcode-substring-search-problem](https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/92007/Sliding-Window-algorithm-template-to-solve-all-the-Leetcode-substring-search-problem.)

首先，如何判断两个字符串同构，242题。

然后用滑动窗口，每次移动一位，调整cs的计数，与cp比较。

```cpp
class Solution {
public:
	vector<int> findAnagrams( string s, string p )
	{
		vector<int>	ret;
		vector<int>	cs( 26, 0 );
		vector<int>	cp( 26, 0 );
		if ( s.length() < p.length() )
			return(ret);
		for ( int i = 0; p[i]; i++ )
		{
			cp[p[i] - 'a']++;
			cs[s[i] - 'a']++;
		}

		if ( cp == cs )
			ret.push_back( 0 );

		for ( int i = p.length(); i < s.length(); i++ )
		{
			cs[s[i] - 'a']++;
			cs[s[i - p.length()] - 'a']--;
			if ( cs == cp )
				ret.push_back( i - p.length() + 1 );
		}

		return(ret);
	}
};
```

##  459. Repeated Substring Pattern

字符串s可以由其子串重复得到。s = s.substr\(0,l\)\* \(s.length\(\)/l\)

子串的长度一定是s的因数。

```cpp
class Solution
{
  public:
	bool repeatedSubstringPattern(string s)
	{

		int length = s.length();
		if (length == 0 || length == 1)
			return false;
		for (int i = 1; i <= s.length() / 2; i++)
		{
			if (length % i == 0)
			{
				string temp;
				for (int j = 0; j < length / i; j++)
					temp += s.substr(0, i);
				if (temp == s)
					return true;
			}
		}
		return false;
	}
};
```

##  821. Shortest Distance to a Character

一个字符串各个字符到字符C的最短距离。

字符串中的C字符距离为0，其他的字符分两次求解，即左右两侧分别求解，取较小值。

从左到右，看左边一位的值+1是否更小，从右到左，看右边一位的值+1是否更小。

```cpp
class Solution
{
  public:
    vector<int> shortestToChar(string S, char C)
    {
        int n = S.size();
        vector<int> ret(n, n);
        for (int i = 0; i < n; i++)
            if (S[i] == C)
                ret[i] = 0;

        for (int i = 1; i < n; i++)
            ret[i] = min(ret[i], ret[i - 1] + 1);

        for (int i = n - 2; i >= 0; i--)
            ret[i] = min(ret[i], ret[i + 1] + 1);
        return ret;
    }
};
```

##  859. Buddy Strings

首先，A和B的长度要相等。

如果A和B是相同的字符串，那么要在交换一组字符后仍然保持相同，必须交换的是相同的字符，即需要A中有重复出现的字符。

如果A和B是不同的字符串，那么必定有且有两个不同的字符，且交换后能满足A'=B

```cpp
class Solution {
public:
    bool buddyStrings(string A, string B) {
        if(A.length()!=B.length())
            return false;
        vector<int>  count(26,0);
        if(A==B){
            for(int i = 0;i<A.length();i++){
                count[ A[i]-'a']++;
                    if(count[A[i]-'a']==2)
                        return true;
            }
            return false;
        
        }
        
        vector<int> diff;
        for(int i = 0 ;i<A.length();i++)
        {
            if(A[i]!=B[i])
                diff.push_back(i);
        }
        
        if(diff.size()!=2)
            return false;
        
        if(A[diff[0]]!=B[diff[1]] || A[diff[1]]!=B[diff[0]])
            return false;
        else
            return true;
    }
};
```

##  392. Is Subsequence

判断s串是不是t串的子序列。

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        
        int i = 0,j=0;
        while(i<s.length() && j<t.length())
        {
            if(s[i]==t[j])
                i++;
            j++;
        }
        return i == s.length();
        
    }
};
```

##  394. Decode String

解码。字母分大小写。

先读字母，直接加到ret中，再读数字，运用atoi将其转为整数，运用重复count次字符串。然后找到'\['对应的'\]'，对两个括号内的字符串进行递归解码，在解码'\]'后的字符串。

```cpp
class Solution
{
  public:
	string decodeString(string s)
	{
		if (s.length() == 0)
			return "";
		string ret;

		int i = 0;
		string temp;
		while (s[i] >= 'a' && s[i] <= 'z' || s[i] >= 'A' && s[i] <= 'Z')
			ret += s[i++];
		while (s[i] >= '0' && s[i] <= '9')
			temp += s[i++];
		int count = atoi(temp.c_str());
		if (count == 0)
			return ret;
		int start = i, end;

		int c = 1;
		while (c != 0 && s[i++])
		{
			if (s[i] == '[')
				c++;
			else if (s[i] == ']')
				c--;
		}
		end = i;
		string ds = decodeString(s.substr(start + 1, end - start - 1));
		for (int i = 0; i < count; i++)
			ret += ds;
		ret += decodeString(s.substr(end + 1));
		return ret;
	}
};
```

##  395. Longest Substring with At Least K Repeating Characters



## 402. Remove K Digits

删除K个数字后，剩下的字符串表示的数字最小。

当一个位数的数满足num\[i\]&gt;num\[i+1\]的时候，这个数是需要被删除的，因为只有删除这个数才能满足得到的数字最小。如果循环到最后一位，则其和尾0比较，会被删除。

删除完之后，先去除前导零，然后判断是否是空串，空串返回0，不是空串返回数值。

```cpp
class Solution
{
  public:
	string removeKdigits(string num, int k)
	{

		string ret;

		while (k > 0)
		{
			int i = 0;

			while (num[i] <= num[i + 1])
				i++;
			num.erase(i, 1);
			k--;
		}

		int index = 0;
		while (num[index] == '0')
			index++;
		if (index == num.size())
			return "0";
		else
			return num.substr(index, num.size() - index);

		return num;
	}
};
```

##  424. Longest Repeating Character Replacement

修改不超过k个字符后，能得到的最长的相同字符字符串。

滑动窗口，i表示末尾，逐步后移，如果不满足最多k个字符的需求，就将start前移，更新count。

```cpp
class Solution
{
  public:
	int characterReplacement(string s, int k)
	{

		int maxcount = 0;
		int ret = 0;
		vector<int> count(26, 0);
		int start = 0;
		for (int i = 0; i < s.length(); i++)
		{
			maxcount = max(maxcount, ++count[s[i] - 'A']);

			while (i - start + 1 - maxcount > k)
			{
				count[s[start] - 'A']--;
				start++;
			}

			ret = max(ret, i - start + 1);
		}
		return ret;
	}
};
```

##  451. Sort Characters By Frequency

根据字符出现频率重新组成字符串。首先用一个map来记录各个字符出现了多少次，然后将unordered\_map转换为vector进行排序，排完序后按照个数的多少进行输出。

```cpp
class Solution
{
  public:
	struct compare
	{
		bool operator()(pair<char, int> p1, pair<char, int> p2)
		{
			return p1.second > p2.second;
		}
	};
	string frequencySort(string s)
	{
		unordered_map<char, int> frequencymap;
		string output;
		int i, j;
		for (i = 0; i < s.length(); i++)
			frequencymap[s[i]]++;
		auto cmp = [](pair<char, int> p1, pair<char, int> p2) { return p1.second > p2.second; };
		vector<pair<char, int>> array(frequencymap.begin(), frequencymap.end());
		//sort(array.begin(), array.end(),compare());
		sort(array.begin(), array.end(), cmp);
		for (i = 0; i < array.size(); i++)
		{
			for (j = 0; j < array[i].second; j++)
			{
				output.push_back(array[i].first);
			}
		}
		return output;
	}
};
```



