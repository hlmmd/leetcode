# 2020年8月

## Weekly Contest 200

### [1534. Count Good Triplets](https://leetcode.com/problems/count-good-triplets/)

brute force

```cpp
class Solution
{
public:
    int countGoodTriplets(vector<int> &arr, int a, int b, int c)
    {
        int count = 0;
        for (int i = 0; i < arr.size() - 2; i++)
        {
            for (int j = i + 1; j < arr.size() - 1; j++)
            {
                if (fabs(arr[i] - arr[j]) > a)
                    continue;
                for (int k = j + 1; k < arr.size(); k++)
                {
                    if (fabs(arr[i] - arr[k]) > c || fabs(arr[j] - arr[k]) > b)
                        continue;
                    count++;
                }
            }
        }

        return count;
    }
};
```

### [1535. Find the Winner of an Array Game](https://leetcode.com/problems/find-the-winner-of-an-array-game/)

主要是保存head（当前最大值）

```cpp
class Solution
{
public:
    int getWinner(vector<int> &arr, int k)
    {

        int head = arr[0];
        int count = 0;
        for (int i = 1; i < arr.size(); i++)
        {
            if (arr[i] > head)
            {
                head = arr[i];
                count = 0;
            }
            if (++count == k)
                return head;
        }

        return head;
    }
};
```

### [1536. Minimum Swaps to Arrange a Binary Grid](https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/)

这道题其实没那么复杂。先统计每行有多少个连续的0（从右往左）

根据贪心策略，第i行需要n-i-1个0，那么找到最近能满足的那一行，进行交换（注意交换是相邻的，所以有一个移动操作）。如果不满足，则返回-1

```cpp
class Solution
{
public:
    int minSwaps(vector<vector<int>> &grid)
    {
        int n = grid.size();
        vector<int> rowZeroCount(n, 0);
        for (int i = 0; i < n; i++)
        {
            for (int j = n - 1; j >= 1; j--)
            {
                if (grid[i][j] == 0)
                    rowZeroCount[i]++;
                else
                    break;
            }
        }
        int rtn = 0;
        for (int k = n - 1; k >= 1; k--)
        {
            int s = n - k - 1;
            int i = s;
            for (; i < n; i++)
            {
                if (rowZeroCount[i] >= k)
                {
                    rtn += i - s;
                    for (int x = i; x > s; x--)
                    {
                        rowZeroCount[x] = rowZeroCount[x - 1];
                    }
                    break;
                }
            }
            if (i == n)
                return -1;
        }

        return rtn;
    }
};
```

### [1537. Get the Maximum Score](https://leetcode.com/problems/get-the-maximum-score/)

看了眼题，看解答也不是很复杂的样子，留个坑以后填吧

[https://leetcode.com/problems/get-the-maximum-score/discuss/767987/JavaC%2B%2B-Two-Pointers-O(1)-Space](https://leetcode.com/problems/get-the-maximum-score/discuss/767987/JavaC%2B%2B-Two-Pointers-O(1)-Space)

