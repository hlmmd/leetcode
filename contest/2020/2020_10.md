# 2020.10

## weekly contest 209

2020.10.04 

以为今天周六，就错过了。。定了个闹钟，以防下次又忘了

### [1608. Special Array With X Elements Greater Than or Equal X](https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x/)

求x，使得nums中大于等于x的数的个数为x

先排序，然后用lower_bound，求出大于等于x的数的个数。

```cpp
class Solution
{
public:
    int specialArray(vector<int> &nums)
    {

        sort(nums.begin(), nums.end());
        for (int i = 0; i <= nums.size(); i++)
        {
            auto it = lower_bound(nums.begin(), nums.end(), i);
            if (nums.end() - it == i)
                return i;
        }
        return -1;
    }
};
```

### [1609. Even Odd Tree](https://leetcode.com/problems/even-odd-tree/)

判断是否是奇偶二叉树：奇数层严格递减，偶数层严格递增。奇数层都是偶数，偶数层都是奇数。

dfs

```cpp
class Solution
{
public:
    unordered_map<int, int> m;
    bool dfs(TreeNode *root, int level)
    {
        if (root == NULL)
            return true;
        int flag_level = level % 2;
        int flag_val = root->val % 2;
        if (!flag_level && !flag_val || flag_level && flag_val)
        {
            return false;
        }
        if (m.find(level) != m.end())
        {
            if (!flag_level && m[level] >= root->val || flag_level && m[level] <= root->val)
                return false;
        }
        m[level] = root->val;

        return dfs(root->left, level + 1) && dfs(root->right, level + 1);
    }
    bool isEvenOddTree(TreeNode *root)
    {
        return dfs(root, 0);
    }
};
```

### [1610. Maximum Number of Visible Points](https://leetcode.com/problems/maximum-number-of-visible-points/)

### [1611. Minimum One Bit Operations to Make Integers Zero](https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/)