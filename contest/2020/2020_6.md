# leetcode contest 2020.6

## weekly contest 192

2020.6.7

中午和xyj约饭，没做。晚上回来补的。

### [1470. Shuffle the Array](https://leetcode.com/problems/shuffle-the-array/)

```cpp
class Solution
{
public:
    vector<int> shuffle(vector<int> &nums, int n)
    {
        vector<int> ret(2 * n);
        for (int i = 0; i < n; i++)
        {
            ret[2 * i] = nums[i];
            ret[2 * i + 1] = nums[i + n];
        }
        return ret;
    }
};
```

### [1471. The k Strongest Values in an Array](https://leetcode.com/problems/the-k-strongest-values-in-an-array/)

### [1472. Design Browser History](https://leetcode.com/problems/design-browser-history/)

### [1473. Paint House III](https://leetcode.com/problems/paint-house-iii/)

## weekly contest 193

2020.6.14

### [1](https://leetcode.com/problems/running-sum-of-1d-array/)

简单求和

```cpp
class Solution
{
public:
    vector<int> runningSum(vector<int> &nums)
    {

        vector<int> ret(nums.size());
        ret[0] = nums[0];
        for (int i = 1; i < nums.size(); i++)
        {
            ret[i] = ret[i - 1] + nums[i];
        }
        return ret;
    }
};
```

### [2](https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/)

```cpp
class Solution
{
public:
    int findLeastNumOfUniqueInts(vector<int> &arr, int k)
    {

        unordered_map<int, int> count;
        for (int i = 0; i < arr.size(); i++)
            count[arr[i]]++;

        vector<int> v;
        for (auto it = count.begin(); it != count.end(); ++it)
            v.push_back(it->second);

        sort(v.begin(), v.end());

        int t = 0;
        for (int i = 0; i < v.size(); i++)
        {
            t += v[i];
            if (t > k)
            {
                return v.size() - i;
            }
        }
        return 0;
    }
};
```

### [3](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)

二分搜索。想到了，但是没按这个思路做下去..

最早多少天，开花的花能构成m个由k个相邻的花组成的花束。

```cpp
int minDays(vector<int>& A, int m, int k) {
        int n = A.size(), left = 1, right = 1e9;
        if (m * k > n) return -1;
        while (left < right) {
            int mid = (left + right) / 2, flow = 0, bouq = 0;
            for (int j = 0; j < n; ++j) {
                if (A[j] > mid) {
                    flow = 0;
                } else if (++flow >= k) {
                    bouq++;
                    flow = 0;
                }
            }
            if (bouq < m) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
```

### [4](5456. Kth Ancestor of a Tree Node)