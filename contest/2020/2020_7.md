# 2020 07

## weekly contest 196

2020.7.5

做了前两题。难顶啊

### [1502. Can Make Arithmetic Progression From Sequence](https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence/)

判断数组重排序后能否组成等差数列。排个序判断一下。

```cpp
class Solution
{
public:
    bool canMakeArithmeticProgression(vector<int> &arr)
    {
        sort(arr.begin(), arr.end());
        int d = arr[1] - arr[0];
        for (int i = 1; i < arr.size() - 1; i++)
        {
            if (arr[i + 1] - arr[i] != d)
                return false;
        }
        return true;
    }
};
```

### [1503. Last Moment Before All Ants Fall Out of a Plank](https://leetcode.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/)

主要是别被题目迷惑了，其实两只蚂蚁碰撞后，可以理解为互换了身份，其实并没有什么影响。所以只需要找到离边最远的那只蚂蚁即可。

```cpp
class Solution
{
public:
    int getLastMoment(int n, vector<int> &left, vector<int> &right)
    {
        sort(left.begin(), left.end());
        sort(right.begin(), right.end());

        int l = left.size() == 0 ? 0 : left.back();
        int r = right.size() == 0 ? 0 : n - right[0];
        return max(l, r);
    }
};
```

### [1504. Count Submatrices With All Ones](https://leetcode.com/problems/count-submatrices-with-all-ones/)

求矩阵的所有全1子矩阵个数

以[i][j]作为矩阵的右下角，dp[i][j]表示从[i][j]起往上数，有多少个1.用动态规划很容易求得。

得到这个数后，再考虑将1*dp[i][j]的矩阵往左，求出min(minv, dp[i][k]); 即能得到更"宽"的全1矩阵个数

```cpp
class Solution
{
public:
    int numSubmat(vector<vector<int>> &mat)
    {
        int m = mat.size();
        int n = mat[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        int ret = 0;
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                if (mat[i][j] == 0)
                    continue;
                dp[i][j] = (i > 0 ? dp[i - 1][j] : 0) + 1;
                int minv = dp[i][j];
                for (int k = j; k >= 0; k--)
                {
                    minv = min(minv, dp[i][k]);
                    ret += minv;
                }
            }
        }
        return ret;
    }
};
```

### [1505. Minimum Possible Integer After at Most K Adjacent Swaps On Digits](https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/)

给一个由数字组成的string，和整数K。在K次交换相邻两个数字后，能得到的最小数是多少